1. Анализ алгоритма: Сортировка выбором (Selection Sort)

Определение:
Сортировка выбором — это алгоритм, который разделяет массив на две части: отсортированную и неотсортированную. На каждом шаге он находит минимальный элемент в неотсортированной части и меняет его местами с первым элементом этой части.

Анализ:

    Внешний цикл выполняется n-1 раз

    Внутренний цикл в худшем случае выполняется n-1, n-2, ..., 1 раз за каждый проход

    Общее количество сравнений: (n-1) + (n-2) + ... + 1 = n(n-1)/2

    Количество обменов: всегда n-1 (один обмен на итерацию)

Временная сложность: O(n²)
Почему O(n²): Два вложенных цикла, где внутренний цикл выполняется в среднем n/2 раз для каждого из n-1 итераций внешнего цикла, что дает n × (n/2) = O(n²) операций.


2. Анализ алгоритма: Сортировка обменом (Bubble Sort)

Определение:
Сортировка обменом — это алгоритм, который многократно проходит по массиву, сравнивая соседние элементы и меняя их местами, если они находятся в неправильном порядке.

Анализ:

    Внешний цикл выполняется до n-1 раз

    Внутренний цикл выполняет n-i-1 сравнений на i-й итерации

    В худшем случае: (n-1) + (n-2) + ... + 1 = n(n-1)/2 сравнений

    В лучшем случае (отсортированный массив): только n-1 сравнений

Временная сложность:

    Худший случай: O(n²)

    Лучший случай: O(n)

    Средний случай: O(n²)

Почему такая сложность: В худшем случае два вложенных цикла по n операций, в лучшем случае оптимизация с флагом позволяет завершиться после первого прохода.


3. Анализ алгоритма: Сортировка вставками (Insertion Sort)

Определение:
Сортировка вставками — это алгоритм, который строит отсортированную последовательность, постепенно вставляя каждый новый элемент в правильную позицию среди уже отсортированных элементов.

Анализ:

    Внешний цикл выполняется n-1 раз

    Внутренний цикл в худшем случае выполняет i сравнений и сдвигов для i-го элемента

    Общее количество операций: 1 + 2 + 3 + ... + (n-1) = n(n-1)/2

    В лучшем случае: только n-1 сравнений

Временная сложность:

    Худший случай: O(n²)

    Лучший случай: O(n)

    Средний случай: O(n²)

Почему такая сложность: В худшем случае для каждого нового элемента нужно сдвигать все предыдущие элементы, в лучшем случае массив уже отсортирован и требуется только проверка.


4. Анализ алгоритма: Сортировка слиянием (Merge Sort)

Определение:
Сортировка слиянием — это алгоритм "разделяй и властвуй", который рекурсивно делит массив пополам, сортирует каждую половину и затем объединяет их в отсортированный массив.

Анализ:

    Массив делится пополам log₂n раз

    На каждом уровне рекурсии выполняется O(n) операций слияния

    Общее количество операций: уровни × операции_на_уровне = log n × O(n)

Временная сложность: O(n log n)
Почему O(n log n): Рекурсивное деление дает log n уровней, на каждом уровне выполняется линейное количество операций слияния.


5. Анализ алгоритма: Сортировка Шелла (Shell Sort)

Определение:
Сортировка Шелла — это улучшенная версия сортировки вставками, которая сравнивает элементы, находящиеся на определенном расстоянии друг от друга, постепенно уменьшая это расстояние.

Анализ:

    Использует последовательность шагов (в данном случае n/2, n/4, ..., 1)

    На каждом шаге выполняет сортировку вставками с этим шагом

    Эффективность зависит от выбора последовательности шагов

Временная сложность:

    Худший случай: O(n²)

    Лучший случай: O(n log n)

    Средний случай: O(n^(3/2)) или O(n log² n)

Почему такая сложность: Большие шаги быстро устраняют массовые нарушения порядка, маленькие шаги эффективно досортировывают почти упорядоченный массив.


6. Анализ алгоритма: Быстрая сортировка (Quick Sort)

Определение:
Быстрая сортировка — это алгоритм "разделяй и властвуй", который выбирает опорный элемент и перераспределяет другие элементы так, чтобы меньшие оказались слева, а большие — справа.

Анализ:

    В лучшем случае опорный элемент делит массив пополам

    В худшем случае опорный элемент минимальный или максимальный

    Рекурсивная глубина: log n в лучшем случае, n в худшем

Временная сложность:

    Худший случай: O(n²)

    Лучший случай: O(n log n)

    Средний случай: O(n log n)

Почему такая сложность: В среднем массив делится на примерно равные части, давая log n уровней рекурсии с O(n) операциями на каждом уровне.


7. Анализ алгоритма: Пирамидальная сортировка (Heap Sort)

Определение:
Пирамидальная сортировка — это алгоритм, который использует структуру данных "двоичная куча" для сортировки элементов.

Анализ:

    Построение кучи: O(n) операций

    Извлечение n элементов: каждый требует O(log n) операций

    Общее количество операций: O(n) + n × O(log n)

Временная сложность: O(n log n)
Почему O(n log n): Построение кучи выполняется за линейное время, а каждое из n извлечений требует логарифмического времени для перестройки кучи.


8. Анализ алгоритма: Последовательный поиск (Linear Search)

Определение:
Последовательный поиск — это простейший алгоритм поиска, который проверяет каждый элемент массива последовательно до тех пор, пока не найдет искомый элемент или не достигнет конца массива.

Анализ:

    В лучшем случае: 1 сравнение (элемент первый)

    В худшем случае: n сравнений (элемент последний или отсутствует)

    В среднем случае: n/2 сравнений

Временная сложность:

    Худший случай: O(n)

    Лучший случай: O(1)

    Средний случай: O(n)

Почему такая сложность: Алгоритм должен в худшем случае проверить все n элементов, в среднем — половину элементов массива.


9. Анализ алгоритма: Бинарный поиск (Binary Search)

Определение:
Бинарный поиск — это эффективный алгоритм поиска в отсортированном массиве, который на каждом шаге делит область поиска пополам.

Анализ:

    На каждом шаге область поиска уменьшается вдвое

    Максимальное количество шагов: log₂n

    На каждом шаге выполняется 1 сравнение

Временная сложность: O(log n)
Почему O(log n): На каждом шаге алгоритм отбрасывает половину оставшихся элементов, поэтому максимальное количество шагов логарифмически зависит от n.


10. Анализ алгоритма: Интерполирующий поиск (Interpolation Search)

Определение:
Интерполирующий поиск — это улучшенный вариант бинарного поиска, который использует интерполяционную формулу для предсказания позиции искомого элемента.

Анализ:

    Использует равномерность распределения данных для точного предсказания позиции

    В лучшем случае находит элемент за 1 шаг

    В худшем случае вырождается в линейный поиск

Временная сложность:

    Худший случай: O(n)

    Лучший случай: O(1)

    Средний случай: O(log log n)

Почему такая сложность: Для равномерно распределенных данных алгоритм очень быстро сужает область поиска, давая двойной логарифм.


11. Анализ алгоритма: Поиск Фибоначчи (Fibonacci Search)

Определение:
Поиск Фибоначчи — это алгоритм поиска, который использует числа Фибоначчи для деления массива на неравные части.

Анализ:

    Использует числа Фибоначчи для определения позиций сравнения

    Не использует операцию деления, только сложение/вычитание

    Требует примерно на 4% больше сравнений чем бинарный поиск

Временная сложность: O(log n)
Почему O(log n): Алгоритм гарантированно уменьшает размер области поиска на каждом шаге, обеспечивая логарифмическое время работы аналогично бинарному поиску.
